#!/usr/bin/python
import cv2
import sys
import numpy as np
import glob
import os
import subprocess
from multiprocessing import Process

class ShapeFromShading:
    def __init__(self, windowPosition):
        self.xWindow = windowPosition[0];
        self.yWindow = windowPosition[1];

    def Run(self, filename, dimensions):
        #print "Running Shape from Shading algorithm for " + filename;
        self.xWindow = -1;
        # Call SFSMain with arguments: Filename, Width, Height, Iterations, Light Vector X Y and Z, Light Position X Y and Z, Albedo, Window position X, Window position Y
        subprocess.call(["SFSMain.exe", filename.replace("\\","/"), str(dimensions[0]), str(dimensions[1]), '90',\
                         '0', '0', '500', \
                         '0', '0', '0', \
                         '150000', str(self.xWindow), str(self.yWindow)], stdin=None, stdout=None, stderr=None, shell=True)
        #depthmapFilename = "depthmaps/" + (filename.replace("\\","/"))[16:-4] + ".out"
        depthmapFilename = "depthmaps/" + (filename.replace("\\","/"))[15:-4] + ".out"

        #print "Shape from shading run on " + filename + " to generate " + depthmapFilename;

        
        return depthmapFilename


class UndistortImage:
    # mtx and dist parameters generated by calibration script
    def __init__(self, mtxFilename, distFilename):
        self.mtx = np.loadtxt(mtxFilename, delimiter=', ')
        self.dist = np.loadtxt(distFilename, delimiter=', ')

    def Run(self, filename):
        img = cv2.imread(filename)
        h,  w = img.shape[:2]
        newcameramtx, roi = cv2.getOptimalNewCameraMatrix(self.mtx, self.dist, (w,h), 1, (w,h))

        # undistort
        dst = cv2.undistort(img, self.mtx, self.dist, None, newcameramtx)

        # crop the image
        x,y,w,h = roi
        dst = dst[y:y+h, x:x+w]
        dimensions = [len(dst[0]), len(dst)];
        correctedFilename = 'correctedImages/' + 'corrected' + filename[15:];
        cv2.imwrite(correctedFilename, dst);

        #print "Distortion correction run on " + filename + " and generated " + correctedFilename;
        #sys.stdout.flush()

        return (correctedFilename, dimensions);


class DepthMapToPointCloud:
    def __init__(self):
        # Camera intrinsics
        #mtx = np.loadtxt(mtxFilename, delimiter=', ');
        # Focal
        #self.fx_d = mtx[0][0];
        #self.fy_d = mtx[1][1];
        # Center position
        #self.px_d = mtx[0][2];
        #self.py_d = mtx[1][2];
        
        self.fx_d = 237
        self.fy_d = 238
        
        self.px_d = 211
        self.py_d = 192

        #self.dc1 = 1;
        #self.dc2 = 0;

    def Run(self, depthmapFilename, correctedFilename):
        # Create point cloud
        depth = np.loadtxt(depthmapFilename, delimiter=',');
        height = len(depth);
        width = len(depth[0]);
        pcloud = np.zeros((height, width, 3));
        minimumDepth = np.amin(depth);
        maximumDepth = np.amax(depth);
        minThresholdDepth = ((maximumDepth - minimumDepth)/8) + minimumDepth;
        maxThresholdDepth = maximumDepth - ((maximumDepth - minimumDepth)/5)
        for u in range(height):
            for v in range(width):
                #z = (1.0/depth(u,v) * self.dc1) + self.dc2;
                vflipped = width - (v + 1)
                z = depth[u][vflipped];

                # Thresholding depth
                # if z < thresholdDepth:
                # #if 1:
                    # #pcloud[u][vflipped][0] = z * (u - self.px_d) / self.fx_d;
                    # #pcloud[u][vflipped][1] = z * (v - self.py_d) / self.fy_d;
                    # pcloud[u][vflipped][0] = z * (u - (height/2)) / self.fx_d;
                    # pcloud[u][vflipped][1] = z * (v - (width/2)) / self.fy_d;
                    # pcloud[u][vflipped][2] = z;
                
                    
                if z >= minThresholdDepth and z <= maxThresholdDepth:
                    pcloud[u][vflipped][0] = z * (u - (height/2)) / self.fx_d;
                    pcloud[u][vflipped][1] = z * (v - (width/2)) / self.fy_d;
                    pcloud[u][vflipped][2] = z;
                else:
                    pcloud[u][vflipped][0] = -111;
                    pcloud[u][vflipped][1] = -111;
                    pcloud[u][vflipped][2] = -111; 
                
            
        pcloudFilename = depthmapFilename[:-4] + '.ply';

        # Load original image to color point cloud points
        correctedImage = cv2.imread(correctedFilename)
        
        # Write PLY point cloud file

        self.WritePLY(pcloudFilename, pcloud, correctedImage);

        #zprint "Point cloud file created for " + depthmapFilename + " with RGB from " + correctedFilename + " to generate " + pcloudFilename;
        #sys.stdout.flush()

    def WritePLY(self, filename, pointCloud, correctedImage):
        height = len(pointCloud);
        width = len(pointCloud[0]);
        
        writeList = [];
        
        # Header
        writeList.append('ply\n');
        writeList.append('format ascii 1.0\n');
        writeList.append('element vertex 0 \n');
        writeList.append('property float x\n');
        writeList.append('property float y\n');
        writeList.append('property float z\n');
        writeList.append('property uchar red\n');
        writeList.append('property uchar green\n');
        writeList.append('property uchar blue\n');
        writeList.append('end_header\n');

        # Body
        vertices = 0;
        for u in range(height):
            for v in range(width):
                if (not (pointCloud[u][v][0] == -111.0)):
                    # Point position
                    writeList.append(str(pointCloud[u][v][0]) + ' ');
                    writeList.append(str(pointCloud[u][v][1]) + ' ');
                    writeList.append(str(pointCloud[u][v][2]) + ' ');

                    # RGB
                    writeList.append(str(correctedImage[u][v][2]) + ' ');
                    writeList.append(str(correctedImage[u][v][1]) + ' ');
                    writeList.append(str(correctedImage[u][v][0]) + '\n');

                    vertices += 1;

        writeList[2] = 'element vertex ' + str(vertices) + '\n';

        f = open(filename, 'w');
        f.writelines(writeList)


def RunReconstruction(imageFilename, windowPosition):
    mtxFilename = 'mtx.out';
    distFilename = 'dist.out';    

    #undistortFilter = UndistortImage(mtxFilename, distFilename);
    #correctedFilename, dimensions = undistortFilter.Run(imageFilename);

    sfsFilter = ShapeFromShading(windowPosition);
    #depthmapFilename = sfsFilter.Run(correctedFilename, dimensions);
    img = cv2.imread(imageFilename)
    h,  w = img.shape[:2]
    dimensions = [w,h]
    depthmapFilename = sfsFilter.Run(imageFilename, dimensions);    
    
    depthToPointCloudFilter = DepthMapToPointCloud(mtxFilename, distFilename);
    depthToPointCloudFilter.Run(depthmapFilename, imageFilename);
    #depthToPointCloudFilter.Run(depthmapFilename, correctedFilename);


if __name__ == "__main__":
    files = glob.glob('correctedImages/*')
    for f in files:
        os.remove(f);
    files = glob.glob('depthmaps/*')
    for f in files:
        os.remove(f);        
    files = glob.glob('pointClouds/*')
    for f in files:
        os.remove(f);


    inputFilenames = glob.glob('originalImages/*.bmp');
    windowPosition = [0,0];
    
    jobs = []
    for imageFilename in inputFilenames:
        p = Process(target=RunReconstruction, args=(imageFilename,windowPosition));
        jobs.append(p);
        p.start();

        windowPosition[0] += 185;
        if windowPosition[0] > (1920-185):
            windowPosition[0] = 0;
            windowPosition[1] += 370;
        
        sys.stdout.flush()

        







    
